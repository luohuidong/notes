# 从输入 URL 到页面展示，中间发生了什么 —— 渲染阶段

当导航完成之后，浏览器将进入渲染阶段。在渲染阶段会包含下面的步骤：

- 继续读取来自服务器的剩余响应数据
- 对响应数据进行解析
- 渲染文档以便用户可以看见
- 执行文档中附带的所有脚本
- 加载所有子资源

渲染阶段的目的就是将 HTML、CSS、JavaScript、图片等文件展示出来让用户可以看见。但是在渲染过程中，浏览器是做了很多东西的，由于渲染机制的复杂性，因此渲染流程会被划分为很多个子阶段，最后输出像素，这个过程就像流水线一样。

按照渲染的时间顺序，流水线可以分为如下几个子阶段：

1. 构建 DOM 树 —— DOM
2. 样式计算 —— Style
3. 布局阶段 —— Layout
4. 分层 —— Layer
5. 绘制 —— Paint
6. 光栅化 —— tiles（分块），raster（光栅化）
7. 合成 —— draw quad（绘制图块的命令）
8. 显示 —— display

其中 1~5 是在渲染进程的主线程中进行，而 6~7 则是在渲染进程中的其它线程里完成。

每个阶段关注以下三点内容：

- 开始每个子阶段都有其**输入的内容**
- 每个子阶段有其**处理过程**
- 每个子阶段会生成**输出内容**

**需要注意的是，从 HTTP 请求回来，就产生了流式的数据，后续的 DOM 树构建、CSS 计算、渲染、合成、绘制，都是尽可能地流式处理前一步的产出。即不需要等到上一步骤完全结束，就开始处理上一步的输出，这样我们在浏览网页时，才会看到逐步出现的页面。**

## DOM：构建 DOM 树

构建 DOM 树阶段：

1. 输入内容：HTML
2. 输出内容：树状结构的 DOM 树

构建 DOM 树的阶段，输入的内容是 HTML，HTML 经过 HTML 解析器解析，最终输出树状结构的 DOM。之所以要构建 DOM 树，是因为浏览器无法直接理解和使用 HTML，所以需要将 HTML 转换为浏览器能够理解的结构 —— DOM 树。DOM 树是保存在内存中的树状结构，可以通过 JavaScript 来查询或修改其内容。

## Style：样式计算

样式计算阶段：

1. 输入内容：CSS
2. 输出内容：ComputedStyle

前面生成了 DOM 树，但是 DOM 节点的样式仍然不知道，要让 DOM 节点拥有正确的样式，就需要样式计算。这个阶段大体可分为三步来完成：

1. 把 CSS 转换为浏览器能够理解的结构
2. 转换样式表中的属性值，使其标准化
3. 计算出 DOM 树中每个节点的具体样式

### 把 CSS 转换为浏览器能够理解的结构

CSS 样式的来源：

- 通过 link 引用的外部 CSS 文件
- `<style>` 标记内的 CSS
- 元素的 style 属性内嵌的 CSS

和 HTML 文件一样，浏览器也是无法直接理解这些纯文本的 CSS 样式，所以当渲染引擎接收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的结构 —— **styleSheets**。

styleSheets 的结构可以通过 `document.styleSheets` 来查看。

### 转换样式表中的属性值，使其标准化

当 CSS 文本转化为浏览器可以理解的结构之后，接下来就是要对其进行属性值的标准化操作。

像 `2em`，`blue`，`bold` 这些类型数值不容易被渲染引擎理解，因此需要转换成像 `32px`，`rgb(0, 0, 255)` 这些引擎容易理解的、标准化的计算值，这个过程就是属性值标准化。

### 计算出 DOM 树中每个节点的具体样式

当样式的属性被标准化后，接下来就需要计算 DOM 树中每个节点的样式属性。样式属性的计算涉及 CSS 的继承规则和层叠规则。

- 继承就是每个 DOM 节点都包含有父节点的样式
- 层叠，它是一个定义了如何合并来自多个源的属性值的算法。它在 CSS 处于核心地位，CSS 的全称“层叠样式表”正式强调了这一点。

样式计算阶段的目的是为了计算出 DOM 节点中每个元素的具体样式，在计算过程中需要遵守 CSS 的继承和层叠两个规则。这个阶段最终输出的内容是每个 DOM 节点的样式，并被保存在 **ComputedStyle** 的结构内。

## Layout：布局阶段

布局阶段：

- 输入内容：DOM 和 ComputedStyle
- 输出内容：包含布局运算结构的布局树

有了 DOM 树和 DOM 树中的元素的样式，还不足以显示页面，因为此时不知道 DOM 元素的几何位置信息。接下来就是计算出 DOM 树中**可见**元素的几何位置，这个计算过程叫做布局。

在布局阶段浏览器要完成两个任务：创建布局树和布局计算。

### 创建布局树

DOM 树含有很多不可见的元素，比如 head 标签，还有使用了 `display:none` 属性的元素。因此在显示之前，还要额外地构建一颗**只包含可见元素的布局树**。

为了创建布局树，浏览器大体上完成了下面的工作：

- 遍历 DOM 树中的所有可见节点，并把这些节点添加到布局树中。
- 而不可见的节点会被布局树忽略掉，如 head 标签下面的全部内容，`display:none` 属性的元素。

### 布局计算

当有了一颗完整的布局树后，就要计算布局树节点的坐标位置。在执行布局操作的时候，会把布局运算的结果重新写回布局树中，所以布局计算的过程中布局树既是输入内容也是输出内容。

> 题外话：渲染树是 16 年之前的东西，chromium 源码中已经完全重构，我们可以把 LayoutTree 看成是渲染树，但是 LayoutTree 跟之前的渲染书还是有一些差别的。

## Layer：分层

分层阶段：

- 输入内容：布局树
- 输出内容：图层树

在生成布局树之后，渲染引擎会根据布局树的特点将其转换为图层树，图层树是渲染流水线后续流程的基础结构。

为什么需要图层树？由于页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等。为了更加方便地实现这些效果，渲染引擎需要为特定的节点生成专用的图层，并生成一颗对应的图层树（LayerTree）。这个图层的概念类似于 PS 中的图层的概念，这些图层叠加在一起构成了最终的页面图像。

布局树中每个节点都有对应的图层，但这并不意味着每个节点都有一个专属的图层，如果一个节点没有专属的图层，那么这个节点就从属于父节点的图层。但不管怎样，最终每一个节点都会直接或间接从属于一个层。

当满足下面其中的条件的元素会被提升为单独的一个图层：

1. 拥有层叠上下文属性的元素会被提升为单独的一层。
2. 需要剪裁的地方也会被创建一个图层。

关于层叠上下文属性，MDN 的 [The stacking context](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context) 已经说得很清楚了。

接下来了解一下裁剪是什么。

假设把 div 的大小限定为 200 \* 200 像素，而 div 里面的文字内容比较多，文字所显示的区域肯定会超出 200 \* 200 的面积，这时候就产生了剪裁，渲染引擎会把裁剪文字内容的一部分用于显示在 div 区域。出现这种裁剪情况的时候，渲染引擎会为文字部分单独创建一个层，如果出现滚动条，滚动条也会被提升为单独的层。

运行下面的例子：

```html
<style>
  div {
    width: 200;
    height: 200;
    overflow: auto;
    background: gray;
  }
</style>
<body>
  <div>
    <p>
      所以元素有了层叠上下文的属性或者需要被剪裁，那么就会被提升成为单独一层，你可以参看下图：
    </p>
    <p>
      从上图我们可以看到，document层上有A和B层，而B层之上又有两个图层。这些图层组织在一起也是一颗树状结构。
    </p>
    <p>
      图层树是基于布局树来创建的，为了找出哪些元素需要在哪些层中，渲染引擎会遍历布局树来创建层树（Update
      LayerTree）。
    </p>
  </div>
</body>
```

打开 Chrome 的 DevTools，随后 Cmd + Shift + p，搜索 layer，我们能非常直观地看到分层的结果。html、div、文本、滚动条，一共四个层，div 与文本并不在同一个层。

## Paint：图层绘制

图层绘制阶段：

- 输入内容：图层树
- 输出内容：包含记录了绘制顺序和绘制指令的绘制列表

在完成图层数的构建之后，渲染引擎会对图层树中的每个图层进行绘制。渲染引擎实现图层的绘制时，会把一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表。这些指令是非常简单的，例如绘制黑色的线、粉色的矩形等等。绘制一个元素通常需要好几条绘制指令，因为每个元素的背景、前景、边框都需要单独的指令去绘制。所以在图层绘制阶段，输出的内容就是这些待绘制的列表。

前面封层的例子仍然可以继续使用，在 DevTools Layers 工具中，选择任意的图层，然后点击 Paint Profiler，就能从 Profiler 中清晰地看到绘制指令。

## Tiles & raster：栅格化操作

栅格化阶段：

- 输入内容：绘制指令
- 输出内容：位图

绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎中的合成线程来完成的。当图层的绘制列表准备好之后，渲染进程的主线程会把该绘制列表提交给合成线程。

接下来说一下合成线程是如何工作的。

在某些情况下，有的图层可以很大，比如有的页面你使用滚动条要滚动好久才能滚动到底部，但是通过视口（viewport），用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要。

基于这个原因，合成线程会将图层划分为图块（tile），这些图块的大小通常是 256x256 或者 512x512。然后合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。而图块是栅格化执行的最小单位。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的。

> 这里出现了位图的概念。位图就是内存里建立一张二维表格，把一张图片的每个像素对应的颜色保存进去。位图信息也是 DOM 树中占据浏览器内存最多的信息，我们在做内存占用优化时，主要就是考虑这一部分。

所以栅格化的阶段，整个流程会经过三个线程：渲染进程的主线程 -> 渲染进程的合成线程 -> 渲染进程的栅格化线程。

栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。GPU 操作是运行在 GPU 进程中，如果栅格化操作使用了 GPU，那么最终生成位图的操作是在 GPU 中完成的，这就涉及到了跨进程操作。

## Draw quad & display：合成和显示

一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令 —— “DrawQuad”，然后将该命令提交给浏览器进程。浏览器进程中有一个叫 viz 组件用来接收 DrawQuad 命令，然后根据 DrawQuad 命令，浏览器将其页面内容绘制到内存中，最后显示在屏幕上。

## 总结

一个完整的渲染流程大致如下：

1. 渲染进程将 HTML 内容转换为能够读懂的 DOM 树结构。
2. 渲染进程将 CSS 样式转换为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式
3. 创建布局树，并计算元素的布局信息。
4. 对布局树进行分层，并生成分层树。
5. 为每个图层生成绘制列表，并提交给合成线程。
6. 合成线程将图层分成图块，并在光栅化线程中将图块转换为位图。
7. 合成线程发送绘制图块命令 DrawQuad 给浏览器进程。
8. 浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。

## 参考资料

- [浏览器工作原理与实践 - 06 | 渲染流程（下）：HTML、CSS 和 JavaScript，是如何变成页面的？](https://time.geekbang.org/column/article/118826)
