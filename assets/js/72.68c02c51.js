(window.webpackJsonp=window.webpackJsonp||[]).push([[72],{290:function(e,a,r){"use strict";r.r(a);var t=r(0),v=Object(t.a)({},(function(){var e=this,a=e.$createElement,r=e._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"基础概念"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#基础概念","aria-hidden":"true"}},[e._v("#")]),e._v(" 基础概念")]),e._v(" "),r("p",[e._v("从 Babel 7 开始，所有的 Babel 模块，都会发布在 npm 包的 "),r("code",[e._v("@babel")]),e._v(" 域下，例如 "),r("code",[e._v("@babel/core")]),e._v(" 和 "),r("code",[e._v("@babel/cli")]),e._v(" 。模块化的设计，使得不同的工具能够针对不同的应用场景进行设计。")]),e._v(" "),r("h2",{attrs:{id:"core-library"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#core-library","aria-hidden":"true"}},[e._v("#")]),e._v(" Core Library")]),e._v(" "),r("p",[e._v("Babel 的核心功能处于 "),r("code",[e._v("@babel/core")]),e._v(" 这个模块中。")]),e._v(" "),r("h2",{attrs:{id:"cli-工具"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#cli-工具","aria-hidden":"true"}},[e._v("#")]),e._v(" CLI 工具")]),e._v(" "),r("p",[r("code",[e._v("@babel/cli")]),e._v(" 工具能够让我们直接在终端中使用 Babel。")]),e._v(" "),r("h2",{attrs:{id:"plugins"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#plugins","aria-hidden":"true"}},[e._v("#")]),e._v(" Plugins")]),e._v(" "),r("p",[e._v("Babel 对代码的转换是以 plugins 的形式呈现的。每个 plugin 都是一个小的 JavaScript 程序，它指示 Babel 如果对代码进行转换。我们甚至可以编写自己的 plugin 来得到想要的转换效果。")]),e._v(" "),r("p",[e._v("想要将 ES2015+ 的语法转换成 ES5，可以使用官方提供的 plugin，如 "),r("code",[e._v("@babel/plugin-transform-arrow-functions")]),e._v(" 。")]),e._v(" "),r("h2",{attrs:{id:"presets"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#presets","aria-hidden":"true"}},[e._v("#")]),e._v(" Presets")]),e._v(" "),r("p",[e._v("我们可以使用 plugin 来指示 Babel 对某个 ES2015+ 语法的转换，但当我们的代码中有多个 ES2015+ 特性需要转换的时候，一个特性配置一个 plugin 未免有些麻烦。为了解决这个问题，我们可以使用 preset。")]),e._v(" "),r("p",[e._v("preset 是一个预设了一组 plugins 的集合。与 plugins 类似，我们也可以自己创建一个 preset，用于分享我们自己的 plugins 组合。")]),e._v(" "),r("p",[e._v("例如 "),r("code",[e._v("@babel/preset-env")]),e._v(" 这个 preset 中，包含了所有支持现代 JavaScript 特性的 plugins。通过这个 preset 我们就无需给每个 ES2015+ 语法配置一个单独的 plugin 来进行处理了。")]),e._v(" "),r("h2",{attrs:{id:"configuration"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#configuration","aria-hidden":"true"}},[e._v("#")]),e._v(" Configuration")]),e._v(" "),r("p",[e._v("每次通过 CLI 工具来执行 Babel 都需要传大量的参数未免有些繁琐，通过编写配置文件可以免除这个烦恼。")]),e._v(" "),r("h2",{attrs:{id:"polyfill"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#polyfill","aria-hidden":"true"}},[e._v("#")]),e._v(" Polyfill")]),e._v(" "),r("p",[e._v("Polyfill 就是将环境中缺失的 feature 给补充上，因此我们在使用 "),r("code",[e._v("@babel/polyfill")]),e._v(" 之后，能够在老的浏览器环境中使用类似于 "),r("code",[e._v("Promise")]),e._v(" 的 ES2015+ 特性.")]),e._v(" "),r("p",[r("code",[e._v("@babel/polyfill")]),e._v(" 模块包含 "),r("code",[e._v("core-js")]),e._v(" 和一个自定义的 regenerator 运行时去模拟整个 ES2015+ 环境。")]),e._v(" "),r("p",[e._v("这就意味着我们可以使用：")]),e._v(" "),r("ul",[r("li",[e._v("类似于 "),r("code",[e._v("Promise")]),e._v(" 或者 "),r("code",[e._v("WeakMap")]),e._v(" 的内置函数。")]),e._v(" "),r("li",[e._v("类似于 "),r("code",[e._v("Array.from")]),e._v(" 或者 "),r("code",[e._v("Object.assign")]),e._v(" 的静态方法。")]),e._v(" "),r("li",[e._v("generator 方法。")])]),e._v(" "),r("p",[e._v("为了做到以上几点，ployfill 添加到 global 上以及原生原型上 (prototypes)，如 "),r("code",[e._v("String")]),e._v(" 。")]),e._v(" "),r("p",[e._v("需要注意的是，在使用 npm 安装 "),r("code",[e._v("@babel/ployfill")]),e._v(" 的时候应该添加 "),r("code",[e._v("--save")]),e._v(" 参数而不是 "),r("code",[e._v("--save-dev")]),e._v(" 参数，polyfill 需要在我们源码之前去执行的。")]),e._v(" "),r("h2",{attrs:{id:"参考资料"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#参考资料","aria-hidden":"true"}},[e._v("#")]),e._v(" 参考资料")]),e._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"https://babeljs.io/docs/en/usage",target:"_blank",rel:"noopener noreferrer"}},[e._v("Usage Guide"),r("OutboundLink")],1)])])])}),[],!1,null,null,null);a.default=v.exports}}]);